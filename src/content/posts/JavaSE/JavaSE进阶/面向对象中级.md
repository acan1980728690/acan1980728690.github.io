---
title: 面向对象中级
published: 2025-08-01 20:04:36
tags: []
category: Java基础
draft: false
---
## 包

 **包的作用**

区分相同的类
当类很多的时候，可以很好的管理类
控制访问范围

 **基本语法**

```
package somethong
```
package关键字，表示打包，something表示包名



**包的本质**

实际上就是创建了不同的文件夹来保存类文件

**包的命名**

命名规则
- 只能包含数字，字母，下划线，但是不能用数字开头，也不能是关键字或保留字

命名规范
- 一般是小写字母+小圆点
- com.公司名.项目名.业务模块名

**常用的包**   

- java.lang默认引入，不需要再引入
- java.util 系统提供的工具包，工具类，使用Scanner
- java.net网络包
- java.awt 做java的界面开发



**引入包**

import 包

import java.util.Scanner;表示只引入一个类Scanner

import java.util.*;表示将java.util的包全部都引入


## 访问修饰符

四种修饰符,public,protected,默认,private
- public:对外公开
- protected,对子类和同一个包中的类公开
- 默认：没有修饰符，对同一个包的类公开
- private:只有类本身可以访问，不对外公开

## 面向对象三大特征

### 封装

封装就是把抽象出的数据（属性）和对数据的操作（方法）封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作（方法），才能对数据进行操作

封装可以隐藏细节

封装可以对数据进行验证，保证安全合理
 
**封装的实现**

属性的私有化(使用private)

提供一个公共的方法set,用来对属性进行判断和赋值

提供一个公共的方法get，用于获取属性的值

构造器问题

- 直接使用构造器会绕过set方法，无法验证数据
- 解决：在构造器里调用set方法
  
### 继承

**概念**
继承可以解决代码复用，当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和 方法，所有的子类不需要重新定义这些属性和方法，只需要通过extends来声明继承父类即可

子类会自动拥有父类定义的属性和方法

父类又叫超类，基类

子类又叫派生
**语法**
```
class 子类 extends 父类{}
```
**细节**

子类继承了所有的属性和方法，但是私有属性和方法不能直接在子类中访问，要通过公开的方法访问

子类必须调用父类的构造器，完成父类的初始化

当创建子类对象时，不管使用子类的那个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过

如果希望指定去调用父类的某个构造器，则显式的调用一下

super在使用时，必须放在构造器第一行

super()和this()都只能放在构造器第一行，因此这两个方法不能共存在一个构造器

java所有类都是Object类的子类

父类构造器的调用不限于直接父类！将一直往上追溯直到Object类（顶级父类）

子类最多只能继承一个父类（指直接继承），即java中是单继承机制

不能滥用继承，子类和父类之间必须瞒住is-a的逻辑关系

**本质**

内存

1. 继承时，先在方法区创建Object,然后随着父类子类一路创建下来
2. 在堆中分配一段空间，然后随着父类子类的顺序分配属性（属性名字不影响）
3. 在栈内创建类的引用,指向堆中的地址
   
通过查找关系找信息

1. 先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息
3. 如果子类没有这个属性，就看父类有没有这个属性
4. 如果父类也没有，就重复上一步，直到找到object中为止

**super关键词**

super代表父类的引用，用于访问父类的属性，方法，构造器
访问父类的属性，看访问修饰符限定范围
- suepr.属性名；

访问父类的方法，看访问修饰符限定范围
- super.方法名（参数列表）；

访问父类的构造器，看访问修饰符限定范围
- super.(参数列表)

super的访问不限于直接父类，如果爷爷类和本类有同名的成员，也可以使用super期访问爷爷类的成员；如果多个基类（上级类）都有同名的成员，使用super访问遵循就近原则，A -> B ->  C

**override方法重写**

介绍

子类有一个方法，和父类的某个方法名称，返回类型，参数都一样，那么我们就说子类的这个方法覆盖了父类的那个方法

注意事项和使用细节

- 子类的方法的参数和方法名称必须都一样
- 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回object，子类方法返回String
- 子类方法不能缩小父类方法的访问权限（访问修饰符）


### 多态

#### 介绍

方法或对象具有多种形态，多态是建立在封装和继承基础之上

#### 多态的具体表现

##### 方法的多态

重写和重载就能体现多态

##### 对象的多态

**一个对象的编译类型和运行类型可以不一致**，编译类型在定义对象时，就确定了，不能改变，运行类型是可以变化的，编译类型看定义时=的左边，运行类型看=的右边

**例子**

- Animal的子类是Dog和Cat
- Animal animal = new Dog() animal编译类型是Animal 运行Dog
- animal = new Cat(); animal的运行类型变成了Cat，编译类型仍然是Animal

**多态的注意事项和细节**

多态的前提是两个类存在继承关系

多态的向上转型
- 本质：父类的引用指向了子类的对象
- 语法：父类类型 引用名 == new 子类类型
- 特点：编译类型看左边，运行类型看右边。可以调用父类中的所有成员（遵循访问修饰符），不能调用子类中特有成员（重写的方法不算特有成员）
- 能调用那些成员，是由编译类型决定的
- 最终运行看子类的具体实现


多态的向下转型
- 语法：子类类型 引用名 = （子类类型）父类引用；
- 只能强转父类的引用，不能强转父类的对象
- 要求父类的引用必须指向的是当前目标类型的对象
- 可以调用子类类型中的所有成员


属性没有重写之说，属性的值看编译类型

instanceOf比较操作符，用于判断对象的类型是否是xx类型或XX类型的子类型（运行类型）
- 例子
```
bb instanceof BB //返回True，bb是BB类型
```

#### java的动态绑定机制

当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定

当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

#### 多态的应用

可以用来创建多态数组或者多态参数()

## Object类

### ==与equals的区别

==对于基本类型和引用类型都可以判断，如果是基本类型，判断值，如果是引用类型，判断对象的引用，也就是判断是不是同个对象

equals是object中的一个方法，只能用来判断引用类型，默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等，比如Interger,String

### hascode


提高具有哈希结构的容器的效率

两个引用，如果指向的是同一个对象，则哈希值肯定是一样的

两个引用，如果指向的是不同对象，则哈希值是不一样的

哈希值主要根据地址号来的，不能完全将哈希值等价于地址

### toString

默认返回：全类名+@ +哈希值的十六进制，子类往往重写toString方法，用于返回对象的属性信息（全类名的意思是包名+类名）

重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式。

当直接输出一个对象时，toString方法会被默认的调用



### finalize

当对象被回收时，系统自动的调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作

什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象时一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法

垃圾回收机制的调用，是由系统来决定（既有自己的gc算法），也可以通过System.gc()主动触发垃圾回收机制
