---
title: 面向对象基础
published: 2025-08-01 19:53:27
tags: []
category: Java基础
draft: false
---
## 面向对象基础

### 递归

递归的意思就是函数自己调用自己

示例：

```
public class Queen {
    public static void main(String[] args) {
        int[][] board = new int[8][8];
        T t = new T();
        for(int i=0;i<8;i++) {
            for (int j = 0; j < 8; j++) {
                board[i][j] = 0;
            }
        }
        t.placeQueen(board,0);
    }
}
class T{
    int[] result = new int[8];
    public void placeQueen(int[][] board,int m){
        if(m==8){
            for(int i=0;i<8;i++){

                System.out.print(result[i] + 1);

            }
            System.out.println();
        }
        else{
            for(int i=0;i<8;i++){
                if(isSafe(board,m,i)){
                    board[m][i]=1;
                    result[m]=i;
                    placeQueen(board,m+1);
                }
                board[m][i]=0;
                result[m]=0;
            }
        }
        }
        public boolean isSafe(int[][] board,int row,int col) {
            for (int i = 0; i < row; i++) {
                if (board[i][col] == 1) {
                    return false;
                }
            }
            int i = row - 1, j = col - 1;
            while (i >= 0 && j >= 0) {
                if (board[i][j] == 1) {
                    return false;
                }
                i--;
                j--;
            }
            i = row - 1;
            j = col + 1;
            while (i >= 0 && j < 8) {
                if (board[i][j] == 1) {
                    return false;
                }
                i--;
                j++;
            }
            return true;
        }
    }
```


### 方法的重载

定义：改变函数的参数列表，其他没有要求

例子:

```
	public void nums(int a,int b){}
	public void nums(double a, double b)
```


### 可变参数

就是方法的重载，但是参数只有个数不同。类型相同

```
public void nums(int ... num)//语法，传进去的参数相当于一个数组
```

**细节**

- 可变参数的实参个数可以是零或者多个
- 可变参数的实质是数组
- 可变参数可以和其他参数一起放在形参列表中，但是必须只有一个可变参数并且可变参数在最后面

### 作用域

1. 属性和局部变量可以重名，访问时遵循就近原则
2. 同一个作用域中不能重名
3. 生命周期都是作用域创建开始，作用域结束就死亡
4. 属性可以加修饰符，局部变量不能加
   
具体看菜鸟

### 构造器

**语法**

` [修饰符] 方法名（参数）{}`

**使用方法**

- 构造器的修饰符可以默认
- 构造器没有返回值
- 方法名必须和类名一样
  
**例子**

```
class Person {
    private String name;
    private int age;
    private String gender;

    public Person(String name, int age, String gender) {
        this.name = name;
        this.age = age;
        this.gender = gender;
    }

    
}
//调用
Person p1 = new Person("Smith",18,"男");
```

**作用**

- 构造器使得在创建类的时候可以直接指定属性的值
 
**细节**

- 一个类可以写多个构造器，即构造器重载
- 构造器是完成对象的初始化，不是创建对象
- 在创建对象的时候，系统自动的调用该类的构造方法
- 如果没有定义构造方法，系统会自动给类生成一个默认无参构造方法，比如Person(){}
	- 一旦定义了自己的构造器，默认的构造器就覆盖了


### 对象创建的流程分析

1. 在方法区加载类
2. 在堆里初始化属性
3. 调用构造器函数，重新赋值（引用类型的值会放在常量区）
4. 在栈里创建对象的引用（对象名），指向这个类


### this关键字

通过this.name这样就可以在成员变量和局部变量相同时，使用this.来访问成员的属性
哪一个对象调用了，this就代表了哪个对象
在堆中被创建的对象里，有一个隐藏属性this,this的值就是对象的内存位置

**细节**

- this关键字可以用来访问本类的属性，方法，构造器
- this用于区分当前类的属性和局部变量
- 访问成员方法的语法：this.方法名（参数列表）;
- 访问构造器语法:this(参数列表);注意只能在构造器中使用，并且只能在构造器第一行（即只能在构造器中调用构造器）
- this不能再类定义的外部使用，只能在类定义的方法中使用
